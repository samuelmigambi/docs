---
title: "Webhook Security"
sidebarTitle: "Webhook Security"
description: "Verify webhook signatures to ensure requests are from Fileloom."
icon: "shield-check"
---

# Webhook Security

When Fileloom sends webhooks to your endpoint, you should verify the signature to ensure the request is authentic and hasn't been tampered with.

## How Webhook Signing Works

Every webhook request includes a signature in the `X-Fileloom-Signature` header. This signature is created using:

1. Your webhook secret (generated when you create the webhook)
2. The raw request body
3. HMAC-SHA256 algorithm

<Steps>
  <Step title="Fileloom Creates Payload">
    When an event occurs (e.g., PDF generated), Fileloom creates a JSON payload with the event data.
  </Step>
  <Step title="Fileloom Signs the Payload">
    Using your webhook secret, Fileloom computes an HMAC-SHA256 signature of the payload.
  </Step>
  <Step title="Your Server Receives the Request">
    The webhook is sent to your endpoint with the signature in the `X-Fileloom-Signature` header.
  </Step>
  <Step title="Your Server Verifies the Signature">
    Using the same secret, your server computes the expected signature and compares it.
  </Step>
  <Step title="Process if Valid">
    If signatures match, the request is authentic. Process the event data.
  </Step>
</Steps>

## Webhook Headers

Each webhook request includes these headers:

| Header                   | Description                        |
| ------------------------ | ---------------------------------- |
| `X-Fileloom-Signature`   | HMAC-SHA256 signature              |
| `X-Fileloom-Timestamp`   | Unix timestamp when sent           |
| `X-Fileloom-Event`       | Event type (e.g., `pdf.generated`) |
| `X-Fileloom-Delivery-Id` | Unique delivery ID                 |

## Verifying Signatures

### Step 1: Get the Signature

Extract the signature from the `X-Fileloom-Signature` header:

```
X-Fileloom-Signature: sha256=a1b2c3d4e5f6...
```

### Step 2: Compute Expected Signature

Using your webhook secret, compute the HMAC-SHA256 of the raw request body.

### Step 3: Compare Signatures

Use a timing-safe comparison to check if the signatures match.

## Code Examples

<CodeGroup>

```javascript Node.js
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const expectedSignature = 'sha256=' + crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('hex');
  
  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// Express.js example
app.post('/webhooks/fileloom', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-fileloom-signature'];
  const payload = req.body.toString();
  
  if (!verifyWebhookSignature(payload, signature, process.env.WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature');
  }
  
  const event = JSON.parse(payload);
  
  // Process the event
  switch (event.type) {
    case 'pdf.generated':
      console.log('PDF generated:', event.data.fileId);
      break;
    case 'pdf.failed':
      console.log('PDF failed:', event.data.error);
      break;
  }
  
  res.status(200).send('OK');
});
```


```python Python
import hmac
import hashlib
import os
from flask import Flask, request, abort

app = Flask(__name__)

def verify_webhook_signature(payload, signature, secret):
    expected = 'sha256=' + hmac.new(
        secret.encode('utf-8'),
        payload,
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected)

@app.route('/webhooks/fileloom', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Fileloom-Signature')
    payload = request.get_data()
    
    if not verify_webhook_signature(payload, signature, os.environ['WEBHOOK_SECRET']):
        abort(401)
    
    event = request.get_json()
    
    if event['type'] == 'pdf.generated':
        print(f"PDF generated: {event['data']['fileId']}")
    elif event['type'] == 'pdf.failed':
        print(f"PDF failed: {event['data']['error']}")
    
    return 'OK', 200
```


```php PHP
<?php

function verifyWebhookSignature($payload, $signature, $secret) {
    $expected = 'sha256=' . hash_hmac('sha256', $payload, $secret);
    return hash_equals($expected, $signature);
}

$payload = file_get_contents('php://input');
$signature = $_SERVER['HTTP_X_FILELOOM_SIGNATURE'] ?? '';
$secret = getenv('WEBHOOK_SECRET');

if (!verifyWebhookSignature($payload, $signature, $secret)) {
    http_response_code(401);
    exit('Invalid signature');
}

$event = json_decode($payload, true);

switch ($event['type']) {
    case 'pdf.generated':
        error_log('PDF generated: ' . $event['data']['fileId']);
        break;
    case 'pdf.failed':
        error_log('PDF failed: ' . $event['data']['error']);
        break;
}

http_response_code(200);
echo 'OK';
```


```go Go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "io"
    "net/http"
    "os"
)

func verifyWebhookSignature(payload []byte, signature, secret string) bool {
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write(payload)
    expected := "sha256=" + hex.EncodeToString(mac.Sum(nil))
    return hmac.Equal([]byte(signature), []byte(expected))
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    signature := r.Header.Get("X-Fileloom-Signature")
    payload, _ := io.ReadAll(r.Body)
    secret := os.Getenv("WEBHOOK_SECRET")
    
    if !verifyWebhookSignature(payload, signature, secret) {
        http.Error(w, "Invalid signature", http.StatusUnauthorized)
        return
    }
    
    var event map[string]interface{}
    json.Unmarshal(payload, &event)
    
    eventType := event["type"].(string)
    
    switch eventType {
    case "pdf.generated":
        // Handle PDF generated
    case "pdf.failed":
        // Handle PDF failed
    }
    
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```


```ruby Ruby
require 'sinatra'
require 'openssl'
require 'json'

def verify_webhook_signature(payload, signature, secret)
  expected = 'sha256=' + OpenSSL::HMAC.hexdigest('sha256', secret, payload)
  Rack::Utils.secure_compare(expected, signature)
end

post '/webhooks/fileloom' do
  payload = request.body.read
  signature = request.env['HTTP_X_FILELOOM_SIGNATURE']
  secret = ENV['WEBHOOK_SECRET']
  
  unless verify_webhook_signature(payload, signature, secret)
    halt 401, 'Invalid signature'
  end
  
  event = JSON.parse(payload)
  
  case event['type']
  when 'pdf.generated'
    puts "PDF generated: #{event['data']['fileId']}"
  when 'pdf.failed'
    puts "PDF failed: #{event['data']['error']}"
  end
  
  status 200
  'OK'
end
```

</CodeGroup>

## Preventing Replay Attacks

Use the `X-Fileloom-Timestamp` header to prevent replay attacks:

```javascript
function verifyWebhook(payload, signature, timestamp, secret) {
  // Reject if timestamp is more than 5 minutes old
  const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 300;
  if (parseInt(timestamp) < fiveMinutesAgo) {
    return false;
  }
  
  // Verify signature
  return verifyWebhookSignature(payload, signature, secret);
}
```

## Webhook Secret Rotation

If your webhook secret is compromised:

<Steps>
  <Step title="Generate New Secret">
    In your dashboard, go to the webhook settings and regenerate the secret.
  </Step>
  <Step title="Update Your Server">
    Deploy the new secret to your webhook handler.
  </Step>
  <Step title="Test the Webhook">
    Use the "Send Test" button to verify it works.
  </Step>
</Steps>

<Warning>
  Regenerating the secret immediately invalidates the old one. Update your server quickly to avoid missing events.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Signature Verification Fails">
    Common causes:

    - **Wrong secret** - Ensure you're using the correct webhook secret
    - **Payload modification** - Don't parse or modify the body before verifying
    - **Encoding issues** - Use raw bytes, not decoded JSON
    - **Extra whitespace** - Some frameworks add whitespace
  </Accordion>
  <Accordion title="Missing Signature Header">
    Check that:

    - Your endpoint is receiving POST requests
    - The `X-Fileloom-Signature` header isn't being stripped by a proxy
    - You're reading the correct header name (case-insensitive)
  </Accordion>
  <Accordion title="Timing-Safe Comparison">
    Always use timing-safe comparison functions:

    - Node.js: `crypto.timingSafeEqual()`
    - Python: `hmac.compare_digest()`
    - PHP: `hash_equals()`
    - Go: `hmac.Equal()`
    - Ruby: `Rack::Utils.secure_compare()`

    Regular string comparison (`===`) is vulnerable to timing attacks.
  </Accordion>
</AccordionGroup>

## Security Checklist

- Verify signature on every webhook request
- Use timing-safe comparison
- Check timestamp to prevent replay attacks
- Store webhook secret in environment variables
- Use HTTPS for your webhook endpoint
- Return 200 quickly, process async if needed
- Log failed verification attempts

## Next Steps

<CardGroup cols={2}>
  <Card title="Webhook Events" icon="bell" href="/webhooks/events">
    See all available webhook events
  </Card>
  <Card title="Webhook Troubleshooting" icon="bug" href="/webhooks/troubleshooting">
    Debug webhook delivery issues
  </Card>
</CardGroup>